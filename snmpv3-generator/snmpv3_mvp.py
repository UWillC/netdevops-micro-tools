import datetime

MODES = ["secure-default", "balanced", "legacy-compatible", "custom"]
OUTPUT_FORMATS = ["cli", "oneline", "template"]


def choose_mode():
    print("Available modes:")
    for m in MODES:
        print(f" - {m}")
    mode = input("Mode (secure-default / balanced / legacy-compatible / custom): ").strip().lower()

    if mode not in MODES:
        raise ValueError(f"Invalid mode: {mode}. Allowed: {', '.join(MODES)}")

    return mode


def choose_output_format():
    print("\nOutput formats:")
    for f in OUTPUT_FORMATS:
        print(f" - {f}")
    fmt = input("Output format (cli / oneline / template) [cli]: ").strip().lower() or "cli"

    if fmt not in OUTPUT_FORMATS:
        raise ValueError(f"Invalid output format: {fmt}. Allowed: {', '.join(OUTPUT_FORMATS)}")

    return fmt


def get_non_empty(prompt: str) -> str:
    value = input(prompt).strip()
    if not value:
        raise ValueError(f"Value for '{prompt}' cannot be empty.")
    return value


def validate_password(pw: str, label: str) -> str:
    """
    Minimal password validation:
    - length < 8  -> error
    - length 8â€“10, no digits, no uppercase -> warning (but allowed)
    """
    if len(pw) < 8:
        raise ValueError(f"{label} password is too short (min 8 characters required).")

    warnings = []

    if len(pw) < 10:
        warnings.append("length < 10")

    if not any(ch.isdigit() for ch in pw):
        warnings.append("no digits")

    if not any(ch.isupper() for ch in pw):
        warnings.append("no uppercase letters")

    if warnings:
        print(f"[WARNING] {label} password is weak ({', '.join(warnings)}).")

    return pw


def resolve_algorithms(mode: str):
    if mode == "secure-default":
        return "SHA-256", "AES-256"
    elif mode == "balanced":
        return "SHA", "AES-128"
    elif mode == "legacy-compatible":
        return "SHA", "AES-128"
    elif mode == "custom":
        auth_algo = get_non_empty("Auth algorithm (SHA/SHA-256/SHA-512): ")
        priv_algo = get_non_empty("Privacy algorithm (AES-128/AES-256): ")
        return auth_algo, priv_algo
    else:
        raise ValueError(f"Unsupported mode: {mode}")


def generate_header(mode: str, device: str):
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    header = f"""!
! SNMPv3 config generated by Cisco Micro-Tool Generator
! Mode: {mode}
! Date: {now}
! Device: {device}
!
"""
    return header


def generate_template_header(mode: str, device: str, host: str):
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    header = f"""# SNMPv3 YAML config generated by Cisco Micro-Tool Generator
# Mode: {mode}
# Date: {now}
# Device: {device}
# Host: {host}

snmpv3_users:
"""
    return header


def generate_snmpv3_cli(user, group, auth_algo, auth_pass, priv_algo, priv_pass, host):
    return f"""
snmp-server view ALL iso included
snmp-server group {group} v3 priv read ALL write ALL
snmp-server user {user} {group} v3 auth {auth_algo} {auth_pass} priv {priv_algo} {priv_pass}
snmp-server host {host} version 3 priv {user}

snmp-server enable traps
"""


def generate_snmpv3_oneline(user, group, auth_algo, auth_pass, priv_algo, priv_pass, host):
    commands = [
        "snmp-server view ALL iso included",
        f"snmp-server group {group} v3 priv read ALL write ALL",
        f"snmp-server user {user} {group} v3 auth {auth_algo} {auth_pass} priv {priv_algo} {priv_pass}",
        f"snmp-server host {host} version 3 priv {user}",
        "snmp-server enable traps",
    ]
    return " ; ".join(commands)


def generate_snmpv3_template_entry(user, group, auth_algo, auth_pass, priv_algo, priv_pass, host):
    # YAML fragment for a single SNMPv3 user
    return f"""  - name: "{user}"
    group: "{group}"
    auth_algo: "{auth_algo}"
    auth_pass: "{auth_pass}"
    priv_algo: "{priv_algo}"
    priv_pass: "{priv_pass}"
    host: "{host}"
"""


def main():
    print("=== SNMPv3 Config Generator v0.4 ===\n")

    # 1. Security mode + output format
    mode = choose_mode()
    device = input("Device type (default: Cisco IOS XE): ").strip() or "Cisco IOS XE"
    host = get_non_empty("SNMP manager IP/hostname (trap host): ")
    output_format = choose_output_format()

    auth_algo, priv_algo = resolve_algorithms(mode)

    num_users_raw = get_non_empty("How many SNMPv3 users to generate?: ")
    try:
        num_users = int(num_users_raw)
        if num_users < 1:
            raise ValueError
    except ValueError:
        raise ValueError("Number of users must be a positive integer.")

    # 2. Generate configs per user
    configs = []

    for i in range(num_users):
        print(f"\n=== User {i+1}/{num_users} ===")
        user = get_non_empty("SNMPv3 username: ")
        default_group = f"{user}_grp"
        group = input(f"Group name [{default_group}]: ").strip() or default_group

        auth_pass = validate_password(get_non_empty("Auth password: "), "Auth")
        priv_pass = validate_password(get_non_empty("Privacy password: "), "Privacy")

        if output_format == "cli":
            cfg = generate_snmpv3_cli(
                user=user,
                group=group,
                auth_algo=auth_algo,
                auth_pass=auth_pass,
                priv_algo=priv_algo,
                priv_pass=priv_pass,
                host=host,
            )
        elif output_format == "oneline":
            cfg = generate_snmpv3_oneline(
                user=user,
                group=group,
                auth_algo=auth_algo,
                auth_pass=auth_pass,
                priv_algo=priv_algo,
                priv_pass=priv_pass,
                host=host,
            )
            cfg = cfg + "\n"
        elif output_format == "template":
            cfg = generate_snmpv3_template_entry(
                user=user,
                group=group,
                auth_algo=auth_algo,
                auth_pass=auth_pass,
                priv_algo=priv_algo,
                priv_pass=priv_pass,
                host=host,
            )
        else:
            raise ValueError(f"Unsupported output format: {output_format}")

        configs.append(cfg)

    # 3. Compose final output
    if output_format == "template":
        full_output = generate_template_header(mode, device, host)
        full_output += "\n".join(configs) + "\n"
    else:
        header = generate_header(mode, device)
        full_output = header + "".join(configs) + "\n"

    # 4. Export
    export = input("\nExport to file? (y/n): ").strip().lower()
    if export == "y":
        default_filename = {
            "cli": "snmpv3_config_cli.txt",
            "oneline": "snmpv3_config_oneline.txt",
            "template": "snmpv3_config.yml",
        }.get(output_format, "snmpv3_config.txt")

        filename = input(f"Filename (default: {default_filename}): ").strip() or default_filename
        with open(filename, "w") as f:
            f.write(full_output)
        print(f"\nSaved to file: {filename}\n")
    else:
        print("\nGenerated configuration:\n")
        print(full_output)


if __name__ == "__main__":
    try:
        main()
    except ValueError as e:
        print(f"\n[ERROR] {e}")
        print("Aborting.\n")
