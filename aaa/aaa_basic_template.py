import datetime


def get_non_empty(prompt: str) -> str:
    value = input(prompt).strip()
    if not value:
        raise ValueError(f"Value for '{prompt}' cannot be empty.")
    return value


def validate_server(server: str) -> str:
    if " " in server:
        raise ValueError("Server hostname/IP cannot contain spaces.")
    return server


def generate_header(device: str):
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    header = f"""!
! AAA / TACACS+ config generated by Cisco Micro-Tool Generator
! Date: {now}
! Device: {device}
!
"""
    return header


def validate_password(pw: str, label: str) -> str:
    """
    Basic password validation:
    - if < 8 characters -> error
    - if 8â€“10, no digits, no uppercase -> warning
    """
    if len(pw) < 8:
        raise ValueError(f"{label} password is too short (min 8 characters required).")

    warnings = []

    if len(pw) < 10:
        warnings.append("length < 10")

    if not any(ch.isdigit() for ch in pw):
        warnings.append("no digits")

    if not any(ch.isupper() for ch in pw):
        warnings.append("no uppercase letters")

    if warnings:
        print(f"[WARNING] {label} password is weak ({', '.join(warnings)}).")

    return pw


def generate_aaa_local_only(enable_secret=None):
    cfg = "\n! AAA local-only baseline\n"
    cfg += "aaa new-model\n"
    cfg += "aaa authentication login default local\n"
    cfg += "aaa authorization exec default local\n"
    cfg += "aaa accounting update periodic 15\n"

    if enable_secret:
        cfg += f"\n! Enable secret\nenable secret {enable_secret}\n"

    cfg += """
! Line configuration
line vty 0 4
 login local
 transport input ssh
!
"""
    return cfg


def generate_aaa_tacacs(
    enable_secret=None,
    tacacs1_name=None,
    tacacs1_ip=None,
    tacacs1_key=None,
    tacacs2_name=None,
    tacacs2_ip=None,
    tacacs2_key=None,
    source_interface=None,
):
    cfg = "\n! AAA with TACACS+ and local fallback\n"
    cfg += "aaa new-model\n"
    cfg += "aaa authentication login default group tacacs+ local\n"
    cfg += "aaa authorization exec default group tacacs+ local\n"
    cfg += "aaa accounting update periodic 15\n"

    if enable_secret:
        cfg += f"\n! Enable secret\nenable secret {enable_secret}\n"

    cfg += "\n! TACACS+ server definitions\n"
    cfg += f"tacacs server {tacacs1_name}\n"
    cfg += f" address ipv4 {tacacs1_ip}\n"
    cfg += f" key {tacacs1_key}\n"

    if tacacs2_name and tacacs2_ip and tacacs2_key:
        cfg += f"\ntacacs server {tacacs2_name}\n"
        cfg += f" address ipv4 {tacacs2_ip}\n"
        cfg += f" key {tacacs2_key}\n"

    if source_interface:
        cfg += f"\n! TACACS+ source interface\nip tacacs source-interface {source_interface}\n"

    cfg += """
! Line configuration
line vty 0 4
 login authentication default
 transport input ssh
!
"""
    return cfg


def generate_oneline(config_block: str) -> str:
    lines = []
    for line in config_block.splitlines():
        line = line.strip()
        if not line or line.startswith("!"):
            continue
        lines.append(line)
    return " ; ".join(lines)


def main():
    print("=== AAA / TACACS+ Config Generator v0.1 ===\n")

    device = input("Device type (default: Cisco IOS XE): ").strip() or "Cisco IOS XE"

    use_tacacs = input("Use TACACS+? (y/n) [y]: ").strip().lower() or "y"

    enable_secret = input("Enable secret (optional, leave empty to skip): ").strip()
    if enable_secret:
        enable_secret = validate_password(enable_secret, "Enable")

    output_format = input("Output format (cli / oneline) [cli]: ").strip().lower() or "cli"
    if output_format not in ["cli", "oneline"]:
        raise ValueError("Invalid output format. Allowed: cli, oneline.")

    if use_tacacs == "y":
        print("\n=== TACACS+ settings ===")
        tacacs1_name = get_non_empty("Primary TACACS+ server name: ")
        tacacs1_ip = validate_server(get_non_empty("Primary TACACS+ server IP/hostname: "))
        tacacs1_key = get_non_empty("Primary TACACS+ key: ")

        use_second = input("Configure secondary TACACS+ server? (y/n): ").strip().lower()
        tacacs2_name = tacacs2_ip = tacacs2_key = None
        if use_second == "y":
            tacacs2_name = get_non_empty("Secondary TACACS+ server name: ")
            tacacs2_ip = validate_server(get_non_empty("Secondary TACACS+ server IP/hostname: "))
            tacacs2_key = get_non_empty("Secondary TACACS+ key: ")

        source_interface = input("Source interface for TACACS+ (optional, e.g. Loopback0): ").strip() or None

        aaa_cfg = generate_aaa_tacacs(
            enable_secret=enable_secret or None,
            tacacs1_name=tacacs1_name,
            tacacs1_ip=tacacs1_ip,
            tacacs1_key=tacacs1_key,
            tacacs2_name=tacacs2_name,
            tacacs2_ip=tacacs2_ip,
            tacacs2_key=tacacs2_key,
            source_interface=source_interface,
        )
    else:
        aaa_cfg = generate_aaa_local_only(enable_secret=enable_secret or None)

    header = generate_header(device)

    if output_format == "cli":
        final_output = header + aaa_cfg + "\n"
    else:
        final_output = header + generate_oneline(aaa_cfg) + "\n"

    export = input("\nExport to file? (y/n): ").strip().lower()
    if export == "y":
        default_filename = "aaa_tacacs_config.txt" if output_format == "cli" else "aaa_tacacs_oneline.txt"
        filename = input(f"Filename (default: {default_filename}): ").strip() or default_filename
        with open(filename, "w") as f:
            f.write(final_output)
        print(f"\nSaved to file: {filename}\n")
    else:
        print("\nGenerated AAA / TACACS+ configuration:\n")
        print(final_output)


if __name__ == "__main__":
    try:
        main()
    except ValueError as e:
        print(f"\n[ERROR] {e}")
        print("Aborting.\n")
